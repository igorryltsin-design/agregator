# Agregator — локальный каталог научных материалов

Agregator — локальное веб-приложение для хранения, структурирования и интеллектуального поиска по научным материалам: статьям, диссертациям, презентациям, аудио и изображениям. Приложение индексирует выбранное хранилище, извлекает метаданные и текст, достраивает теги, строит граф связей и предоставляет расширенный интерфейс с поддержкой AI-поиска, статистики и прав доступа.

## Содержание
- [Ключевые возможности](#ключевые-возможности)
- [Архитектура](#архитектура)
- [Поддерживаемые форматы и обработка контента](#поддерживаемые-форматы-и-обработка-контента)
- [Пользователи, роли и безопасность](#пользователи-роли-и-безопасность)
- [Веб-интерфейсы](#веб-интерфейсы)
- [Установка и запуск](#установка-и-запуск)
- [Конфигурация](#конфигурация)
- [Импорт, загрузка и сканирование](#импорт-загрузка-и-сканирование)
- [AI и интеллектуальные функции](#ai-и-интеллектуальные-функции)
- [REST API](#rest-api)
- [Сборка фронтендов](#сборка-фронтендов)
- [Структура репозитория](#структура-репозитория)
- [Резервное копирование и обслуживание](#резервное-копирование-и-обслуживание)
- [Лицензия](#лицензия)

## Ключевые возможности
- Полноценная многопользовательская модель с ролями `admin`/`user`, приватными коллекциями и ACL (viewer/editor/owner) для совместной работы.
- Интеллектуальное сканирование библиотеки: извлечение текста, OCR, автодетект типа материала, генерация тегов и метаданных с помощью LLM.
- Быстрый поиск: текстовый, фасетный, по тегам и годам, с морфологией и синонимами (Natasha + pymorphy2).
- AI-поиск с расширением запроса, реранжированием, глубоким просмотром фрагментов и генерацией краткого ответа со ссылками на источники.
- Визуализация графа связей «файл → теги» и дашборд статистики по типам, периодам, размерам и заполненности метаданных.
- Массовый импорт и выгрузка файлов, автосоздание коллекций, управление размещением и переименованием из интерфейса.
- Расширенная админ-панель: управление пользователями, LLM-эндпоинтами, очередью задач, логом действий, бэкапами.
- Экспорт набора в CSV/BibTeX, отдельный интерфейс AiWord для интеграции с внешними инструментами.
- Готовые Docker/Docker Compose конфигурации и вспомогательные скрипты (`start.sh`, `start.bat`).

## Архитектура
### Backend
- `Flask` + `SQLAlchemy` (см. `app.py`, `routes.py`, `models.py`). Приложение работает из коробки с SQLite (`catalogue.db`), поддерживает многопоточную обработку задач.
- REST API разделён между основным приложением (`app.py`) и блюпринтом `routes.py` (файлы, коллекции, экспорт, AI-подсистемы).
- Фоновое сканирование библиотеки, импорт и AI-поиск выполняются в потоках с прогрессом, фиксируются в таблицах `TaskRecord` и `UserActionLog`.
- Поддерживаются российская морфология (Natasha, pymorphy2), словарь синонимов, кеши текстовых фрагментов и миниатюр.
- Интеграция с внешними LLM через LM Studio / OpenAI-совместимые API, в том числе для реранжирования поиска, извлечения метаданных, суммаризации и анализа изображений.

### Frontend
- Основной интерфейс расположен в `frontend/` (React 18 + Vite, Bootstrap, Chart.js, vis-network). Продакшн-сборка попадает в `frontend/dist` и раздаётся Flask'ом.
- Дополнительный интерфейс AiWord (см. `AiWord/`) построен на Vite + Tailwind и публикуется под `/aiword`. Доступ управляется через модель `AiWordAccess`.

### Хранилище данных
- Основная библиотека файлов располагается в `SCAN_ROOT` (по умолчанию `sample_library/`). Пользовательские загрузки сохраняются в `library/` или выбранную коллекцию.
- База данных SQLite (`catalogue.db`) лежит в корне репозитория; резервные копии сохраняются в `backups/`.
- Кешированные тексты и миниатюры хранятся в `static/cache` и `static/thumbnails`; пересоздаются при полном сканировании.
- Текущие параметры работы UI сохраняются в `runtime_settings.json` и доступны через страницу настроек.

## Поддерживаемые форматы и обработка контента
- **Документы**: PDF (PyMuPDF), DOCX, RTF, TXT, EPUB, DJVU. Текстовые фрагменты ограничиваются по длине, сохраняются в базе и/или файловом кеше.
- **OCR**: для картинок и сканов используется `pytesseract`, языки и глубина сканирования настраиваются (`OCR_LANGS_CFG`, `PDF_OCR_PAGES_CFG`, `ALWAYS_OCR_FIRST_PAGE_DISSERTATION`).
- **Аудио**: WAV/MP3/FLAC и др. преобразуются через `ffmpeg` и расшифровываются `faster-whisper` (с загрузкой моделей через HuggingFace Hub).
- **Изображения**: извлекаются метаданные, миниатюры, при включённой опции `IMAGES_VISION_ENABLED` вызывается LLM для описания и ключевых слов.
- **Теги и метаданные**: автозаполнение из распознанного текста, словаря, LLM и из пользовательских схем (`TagSchema`).

## Пользователи, роли и безопасность
- Роли уровня приложения: `admin` (полный доступ) и `user` (доступ в пределах разрешённых коллекций).
- Коллекции поддерживают приватный режим и ACL через `CollectionMember` с ролями `viewer`, `editor`, `owner`; администратор всегда имеет доступ.
- При первом запуске создаётся администратор `DEFAULT_ADMIN_USER` (по умолчанию `admin`). Пароль задаётся через `DEFAULT_ADMIN_PASSWORD` или автоматически генерируется из `ACCESS_CODE`/значения по умолчанию.
- Ограничение загрузок регулируется `MAX_CONTENT_LENGTH` (по умолчанию 50 МБ).
- Доступ к AiWord ограничивается таблицей `AiWordAccess`; права выдаются только администраторами.
- Для совместимости поддерживается опциональный «код доступа» (`ACCESS_CODE`) и basic-auth для legacy-интерфейсов.

## Веб-интерфейсы
- **Каталог (`/app`)**:
  - классический поиск с морфологией и синонимами, фильтры по типу, году, размеру, коллекции, тегам;
  - предпросмотр текста, изображений, PDF и аудио, отображение ключевых тегов и метаданных;
  - inline-редактор карточки, массовое применение тегов, переименование и перенос между коллекциями;
  - переключение в режим AI-поиска с отображением прогресса, ответом LLM и ссылками на найденные фрагменты.
- **Граф (`/graph`)**: визуализация узлов файлов и тегов (автор, организация, консультант и др.), фильтрация по годам и ключам, smart-фильтр на основе морфологии.
- **Статистика (`/stats`)**: графики распределений по типу, месяцам, размерам, заполненности метаданных; экспорт данных в CSV.
- **Импорт и загрузка (`/upload`, `/import`)**: одиночные и массовые загрузки с автосозданием коллекций, фильтрацией по допустимым расширениям и автоприсвоением владельца.
- **Администрирование**:
  - настройки приложения (`/app/settings`): SCAN_ROOT, OCR, AI-возможности, директории по типам, параметры импорта;
  - управление пользователями, коллекциями и правами (`/app/admin/users`, `/api/admin/users`);
  - мониторинг задач (`/app/admin/tasks`), журнал действий, ручной запуск сканирования, выгрузка/очистка БД, управление LLM-эндпоинтами.
- **AiWord (`/aiword`)**: облегчённая витрина для интеграции с внешними инструментами, поддерживает поиск, фильтры и экспорт BibTeX. Требует отдельного допуска.

## Установка и запуск
### Зависимости
- Python 3.10+;
- SQLite (поставляется вместе с Python), Git;
- `tesseract-ocr` (для OCR), `ffmpeg`/`ffprobe` (для аудио);
- Опционально: Node.js 18+ (для пересборки фронтенда), LM Studio или другой OpenAI-совместимый сервер LLM.

### Быстрый старт (Python)
```bash
# Клонирование и окружение
python3 -m venv .venv
source .venv/bin/activate  # Windows PowerShell: .\.venv\Scripts\Activate.ps1
pip install -r requirements.txt

# Настройка окружения
cp .env.example .env   # задайте SCAN_ROOT и, при необходимости, LMSTUDIO_* и TRANSCRIBE_*

# (Опционально) сборка фронтенда
cd frontend && npm install && npm run build && cd ..

# Запуск приложения
python app.py  # UI будет доступен по адресу http://localhost:5050/app
```
При первом старте создаётся `catalogue.db` и базовая коллекция. Значение `SCAN_ROOT` можно менять из UI без перезапуска.

### Docker / Docker Compose
```bash
docker compose build
docker compose up -d
```
Контейнер слушает порт `5050`, монтирует `./library` в `/data` и использует переменные окружения из `docker-compose.yml` / `docker-compose.override.yml`. Для ручной сборки образа см. `Dockerfile`.

### Скрипты запуска
- `start.sh` — пример запуска под `conda` с автоматической сборкой фронтенда.
- `start.bat` — аналогичный сценарий для Windows.

## Конфигурация
### Файл `.env`
| Переменная | Назначение |
| --- | --- |
| `SCAN_ROOT` | Абсолютный путь к директории с материалами. Можно изменить из UI. |
| `EXTRACT_TEXT` | Включить извлечение текста при сканировании (True/False). |
| `LMSTUDIO_API_BASE`, `LMSTUDIO_MODEL`, `LMSTUDIO_API_KEY` | Настройки подключения к LM Studio или OpenAI-совместимому API. |
| `DEFAULT_USE_LLM` | Включить LLM-обработку при сканировании по умолчанию. |
| `DEFAULT_PRUNE` | Удалять из базы записи об отсутствующих файлах по умолчанию. |
| `TRANSCRIBE_ENABLED`, `TRANSCRIBE_BACKEND`, `TRANSCRIBE_MODEL_PATH`, `TRANSCRIBE_LANGUAGE`, `FASTER_WHISPER_CACHE_DIR` | Настройки офлайн-транскрибации аудио. |
| `MAX_CONTENT_LENGTH` | Максимальный размер загружаемого файла (байт). |
| `DEFAULT_ADMIN_USER`, `DEFAULT_ADMIN_PASSWORD` | Учетные данные первого администратора. |
| `ACCESS_CODE` | Опциональный код доступа в UI (legacy-режим). |
| Прочие (`OCR_LANGS`, `PDF_OCR_PAGES`, `OCR_DISS_FIRST_PAGE`) | Аргументы для OCR внутри Docker/приложения. |

### Runtime-настройки (UI → Настройки)
Сохраняются в `runtime_settings.json`, в том числе:
- `SCAN_ROOT`, `IMPORT_SUBDIR`, `MOVE_ON_RENAME`, `TYPE_DIRS` — пути и политика размещения файлов;
- `EXTRACT_TEXT`, `PDF_OCR_PAGES_CFG`, `OCR_LANGS_CFG`, `ALWAYS_OCR_FIRST_PAGE_DISSERTATION` — параметры извлечения текста и OCR;
- `TRANSCRIBE_ENABLED`, `TRANSCRIBE_MODEL_PATH`, `AUDIO_KEYWORDS_LLM`, `SUMMARIZE_AUDIO` — обработка аудио;
- `IMAGES_VISION_ENABLED`, `TYPE_DETECT_FLOW`, `TYPE_LLM_OVERRIDE`, `KEYWORDS_TO_TAGS_ENABLED` — логика определения типа, тегов и автозаполнения;
- `AI_RERANK_LLM`, `LMSTUDIO_*` — использование LLM в поиске.
Настройки можно менять из UI; большинство применяются без перезапуска.

### LLM-эндпоинты
Администратор может добавить несколько эндпоинтов (`/api/admin/llm-endpoints`), указав модель, базовый URL и назначение (`rerank`, `summary`, `metadata`, `vision`, `keywords`, `default`). Внутри приложения работает round-robin и health-check по сигнатурам.

## Импорт, загрузка и сканирование
1. **Загрузка** — через `/upload` (одиночные файлы) или `/import` (папки). Можно создать новую коллекцию, назначить приватность, указать теги.
2. **Ручное копирование** — положите файлы в `SCAN_ROOT` или выбранный подкаталог (`IMPORT_SUBDIR`).
3. **Сканирование** — запустите из UI кнопку «Сканировать» или выполните `POST /scan/start` с флагами `extract_text`, `use_llm`, `prune`. Процесс:
   - проходит по файловой системе, актуализирует записи в БД;
   - извлекает текст/метаданные, выполняет OCR/LLM согласно настройкам;
   - создаёт и обновляет теги, очищает кеши при полном запуске;
   - при `prune=true` удаляет записи об отсутствующих файлах.
   Прогресс доступен по `/scan/status`, остановка — `POST /scan/cancel`.
4. **Перемещение и переименование** — доступно из UI; при изменении типа файла включённый `MOVE_ON_RENAME` переносит его в директорию `TYPE_DIRS[material_type]` (по умолчанию `dissertation`, `article`, `audio`, `image`, `other`).
5. **Освежение метаданных** — `POST /api/files/<id>/refresh` пересканирует конкретный файл, `/api/files/<id>/rename-suggest`/`rename` помогают с массовым переименованием.

## AI и интеллектуальные функции
- **Морфология и синонимы**: токенизация через Razdel, лемматизация pymorphy2, расширение запроса словарём `_RU_SYNONYMS`.
- **Поиск**: стандартный (`/api/search`, `/api/search_v2`) и AI-поиск (`/api/ai-search`, `/api/ai-search/stream`) с расширением ключевых слов, реранжированием и стриминговым прогрессом.
- **LLM-обработка**: извлечение метаданных, ключевых слов, типов материалов, генерация аннотаций и ответов. Поддерживаются кастомные промпты (`runtime_settings.json → PROMPTS`).
- **Аудио**: расшифровка faster-whisper, подсчёт длительности, генерация кратких резюме и ключевых слов (по флагам `SUMMARIZE_AUDIO`, `AUDIO_KEYWORDS_LLM`).
- **Изображения**: при включении vision-режима вызывается LLM для описания и тегов.
- **Экспорт в BibTeX**: эндпоинт `/api/aiword/bibtex` преобразует карточки в библиографические записи с учётом тегов.

## REST API
Основные эндпоинты (требуют авторизации через сессию/куки):

| Endpoint | Метод(ы) | Описание |
| --- | --- | --- |
| `/api/auth/login`, `/api/auth/logout`, `/api/auth/me`, `/api/auth/password` | POST/GET | Аутентификация и смена пароля. |
| `/api/files` | GET, POST | Получение последних файлов, создание записи. |
| `/api/files/<id>` | GET, PUT | Детали файла, обновление метаданных/тегов. |
| `/api/files/<id>/refresh` | POST | Форсированное пересканирование файла. |
| `/api/files/<id>/rename(-suggest)` | GET/POST | Подсказка и применение шаблона переименования. |
| `/api/collections` | GET | Список доступных коллекций. |
| `/api/collections/<id>/members` | GET, POST, PATCH, DELETE | Управление участниками коллекции (ACL). |
| `/api/search`, `/api/search_v2` | GET | Стандартный поиск и фасетные данные. |
| `/api/facets` | GET | Фасеты по тегам и типам. |
| `/api/graph`, `/api/graph/build` | GET, POST | Построение графа связей и автодобавление тегов. |
| `/api/stats`, `/api/stats/tag-values` | GET | Дашборд статистики. |
| `/export/csv`, `/export/bibtex`, `/api/aiword/bibtex` | GET | Экспорт каталога. |
| `/api/ai-search`, `/api/ai-search/stream` | POST | AI-поиск (JSON/Server-Sent Events). |
| `/api/admin/users`, `/api/admin/tasks`, `/api/admin/llm-endpoints`, `/api/admin/actions` | GET/POST/PATCH/DELETE | Администрирование пользователей, задач, LLM, логов. |
| `/scan/start`, `/scan/status`, `/scan/cancel` | POST/GET | Управление фоновым сканированием. |
| `/admin/backup-db`, `/admin/clear-db`, `/admin/import-db` | POST | Обслуживание базы данных. |

Полный список маршрутов см. в `app.py` и `routes.py`.

## Сборка фронтендов
### Основной интерфейс (`frontend/`)
```bash
cd frontend
npm install
npm run dev    # дев-сервер Vite на 5173 (прокси можно настроить вручную)
npm run build  # продакшн-сборка в dist/
```
Сборка `dist/` автоматически подхватывается Flask'ом.

### AiWord (`AiWord/`)
```bash
cd AiWord
npm install
npm run build  # результат в AiWord/dist/
```
Готовая сборка нужна для корректного отображения `/aiword`. В Docker-образе ожидается наличие `AiWord/dist`.

## Структура репозитория
- `app.py` — основной Flask-приложение, UI-маршруты, фоновые задачи, AI-поиск.
- `routes.py` — REST-блюпринт (файлы, коллекции, экспорт, AiWord-эндпоинты).
- `models.py` — SQLAlchemy-модели (пользователи, коллекции, файлы, теги, задачи, LLM-эндпоинты и др.).
- `frontend/` — React/Vite интерфейс каталога; `dist/` служит статикой.
- `AiWord/` — альтернативный UI и интеграция с внешними сервисами.
- `static/` — кеш текстов и миниатюр.
- `library/`, `sample_library/` — фактическое хранилище файлов (боевое и пример).
- `runtime_settings.json` — сохранённые параметры приложения.
- `docker-compose.yml`, `Dockerfile` — контейнеризация.
- `scripts/` — утилиты для проверки ffmpeg/faster-whisper.
- `README_DEPLOY.md` — дополнительные заметки по развёртыванию.

## Резервное копирование и обслуживание
- `POST /admin/backup-db` сохраняет копию `catalogue.db` в `backups/` с меткой времени.
- `POST /admin/import-db` заменяет текущую базу загруженным файлом (перед заменой создаётся резервная копия).
- `POST /admin/clear-db` очищает таблицы файлов/тегов и удаляет кеши миниатюр/текстов.
- Очередь задач (`TaskRecord`) и лог действий (`UserActionLog`) доступны в админ-панели.
- Для обновления среза файлов используется плановое сканирование (`scan/start`); прогресс отображается в UI и через API.

## Лицензия
Проект распространяется по лицензии **MIT NonCommercial** (см. `LICENSE`): свободное использование в личных, образовательных и исследовательских целях; коммерческое использование требует согласования с правообладателем.
