# Предложение по рефакторингу фасетов и индексации

## Текущее состояние
- Эндпоинты `/api/facets`, `/api/facet-config` реализованы внутри `app.py`, работают напрямую через SQLAlchemy.
- Подсчёты по тегам и типам выполняются на лету при каждом запросе; кэш `FACET_CACHE` хранится в памяти процесса.
- Нормализация параметров (`collection_ids`, `tag_filters`, `material_types`) размазана по коду; проверка прав доступа встроена в SQL-запросы.
- Нет отдельного слоя индексации, повторное вычисление тяжёлых запросов происходит при «глубоком поиске» и фасетах.
- Кэш не инвалидируется для модификаций коллекций/тегов за пределами рантайм-функций.

## Цели рефакторинга
1. Вынести фасетную логику в сервисный слой (например, `agregator/services/facets.py`).
2. Унифицировать ключи фасетного кэша, добавив версионирование и явное управление инвалидацией.
3. Подготовить основу для фоновой индексации (расчёт частот и популярных значений вне HTTP-запросов).
4. Упростить добавление новых измерений (например, размер, период, пользовательские поля).

## Предлагаемые шаги
1. **Создать сервис фасетов**
   - интерфейс `FacetService` с методами `get_facets(context, params)` и `invalidate(reason, scope)`.
   - инкапсулировать работу с `FACET_CACHE`, перенести туда `build_payload` из `app.py`.
2. **Перенести конфигурацию**
   - DTO/датакласс для `FacetConfig` (ключи, включение типов, лимиты) и методы загрузки/сохранения;
   - `api_facet_config` использовать сервис, убрать дублирование.
3. **Рефакторинг SQL-запросов**
   - собрать генерацию базового `Query` в отдельные функции (`build_base_query`, `apply_filters`).
   - подготавливать список ID заранее, использовать `session.execute` для массовых операций.
4. **Кэширование и инвалидация**
   - добавить версию (`cache_version`) в ключ кэша;
   - вызывать `facets_service.invalidate()` из `_invalidate_facets_cache` и при изменении коллекций/тегов.
5. **Подсветка и индекс**
   - подготовить вспомогательную таблицу/файл с частотами тегов (по расписанию или при изменениях);
   - рассмотреть использование фоновой задачи (TaskQueue) для обновления агрегатов.
6. **Тестирование**
   - написать unit-тесты для `FacetService` (проверка фильтров, кэша, инвалидации);
   - добавить smoke-тесты REST-эндпоинтов (pytest + flask client).

## Вопросы/риски
- Объём данных: нужно измерить, хватает ли in-memory кэша или требуется внешний (Redis).
- Права доступа: для приватных коллекций важно включить scope пользователя в ключ кэша.
- Совместимость: убедиться, что фронтенд корректно обрабатывает новый ответ (возможны изменения поля `tag_facets`).

## TODO-лист
- [ ] Спецификация интерфейса `FacetService` и выбор формата хранения кэша.
- [ ] Перенос `build_payload` и связанных SQL-запросов в сервис.
- [ ] Реализация инвалидации и versioning фасетного кэша.
- [ ] Добавление unit/интеграционных тестов для фасетов.
- [ ] Подготовка фонового индекса (при необходимости) и метрик по времени отклика фасетного API.
