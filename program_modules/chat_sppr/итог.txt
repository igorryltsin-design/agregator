===== README.md =====
# Интеллектуальный чат СППР

Модуль реализует диалоговый контур для взаимодействия оператора с накопленной многомодальной информацией. Поддерживаются управление сессиями, анализ намерений, формирование ответов с указанием источников и регистрация обратной связи.

## Возможности
- регистрация пользователей и параллельных сессий с ограничением простоя;
- приём пользовательских вопросов, определение намерений и подбор релевантных фрагментов контекста;
- генерация ответов с упоминанием источников и рейтингом уверенности;
- предложения действий и фиксация обратной связи;
- REST/CLI интерфейсы для интеграции с другими подсистемами.

## Запуск
```bash
python -m program_modules.chat_sppr.cli runserver --host 0.0.0.0 --port 8451
```

CLI-команды: `ensure-user`, `start-session`, `ask`, `history`, `close-session`, `report`, `watchdog`, `runserver`.


===== __init__.py =====
"""Intelligent chat SPPR module package."""

from .bootstrap import build_context
from .app import create_app

__all__ = ["build_context", "create_app"]


===== app.py =====
"""Flask application entry point for chat module."""

from __future__ import annotations

import atexit

from flask import Flask

from .api.routes import create_blueprint
from .bootstrap import build_context


def create_app() -> Flask:
    ctx = build_context()
    app = Flask(__name__)
    app.config["CHAT_CONFIG"] = ctx.config
    app.register_blueprint(create_blueprint(ctx.engine), url_prefix="/chat")
    atexit.register(ctx.engine.shutdown)
    return app


if __name__ == "__main__":
    app = create_app()
    app.run(host="0.0.0.0", port=8451)


===== bootstrap.py =====
"""Bootstrap helper for chat module."""

from __future__ import annotations

from dataclasses import dataclass

from .config import AppConfig, load_config
from .database import Database
from .engine import ChatEngine
from .logging_setup import setup_logging


@dataclass
class ChatContext:
    config: AppConfig
    database: Database
    engine: ChatEngine


def build_context(base_dir=None) -> ChatContext:
    setup_logging()
    config = load_config(base_dir)
    database = Database(config.database_url)
    database.create_all()
    engine = ChatEngine(config, database)
    return ChatContext(config=config, database=database, engine=engine)


===== cli.py =====
"""CLI for the chat module."""

from __future__ import annotations

import argparse
import json
from pathlib import Path

from .bootstrap import build_context


def _print(data):
    print(json.dumps(data, indent=2, ensure_ascii=False))


def build_parser():
    parser = argparse.ArgumentParser(description="Chat SPPR CLI")
    sub = parser.add_subparsers(dest="command", required=True)

    user = sub.add_parser("ensure-user", help="Create or fetch user")
    user.add_argument("--username", required=True)
    user.add_argument("--display-name")
    user.add_argument("--role", default="operator")
    user.add_argument("--base-dir")
    user.set_defaults(cmd="ensure-user")

    start = sub.add_parser("start-session", help="Start chat session")
    start.add_argument("--user-id", type=int, required=True)
    start.add_argument("--title", required=True)
    start.add_argument("--base-dir")
    start.set_defaults(cmd="start-session")

    ask = sub.add_parser("ask", help="Send question")
    ask.add_argument("--session-id", type=int, required=True)
    ask.add_argument("--user-message", required=True)
    ask.add_argument("--base-dir")
    ask.set_defaults(cmd="ask")

    history = sub.add_parser("history", help="Show history")
    history.add_argument("--session-id", type=int, required=True)
    history.add_argument("--limit", type=int, default=20)
    history.add_argument("--base-dir")
    history.set_defaults(cmd="history")

    close = sub.add_parser("close-session", help="Close session")
    close.add_argument("--session-id", type=int, required=True)
    close.add_argument("--base-dir")
    close.set_defaults(cmd="close-session")

    report = sub.add_parser("report", help="Show telemetry report")
    report.add_argument("--base-dir")
    report.set_defaults(cmd="report")

    watchdog = sub.add_parser("watchdog", help="Run diagnostics")
    watchdog.add_argument("--base-dir")
    watchdog.set_defaults(cmd="watchdog")

    serve = sub.add_parser("runserver", help="Start HTTP server")
    serve.add_argument("--host", default="0.0.0.0")
    serve.add_argument("--port", type=int, default=8451)
    serve.add_argument("--base-dir")
    serve.set_defaults(cmd="runserver")

    return parser


def main():
    parser = build_parser()
    args = parser.parse_args()
    ctx = build_context(Path(args.base_dir) if getattr(args, "base_dir", None) else None)

    if args.command == "ensure-user":
        payload = {
            "username": args.username,
            "display_name": args.display_name or args.username,
            "role": args.role,
        }
        result = ctx.engine.ensure_user(payload)
        _print(result.payload)
    elif args.command == "start-session":
        result = ctx.engine.start_session({"user_id": args.user_id, "title": args.title})
        _print(result.payload if result.ok else {"error": result.error})
    elif args.command == "ask":
        result = ctx.engine.ask({"session_id": args.session_id, "user_message": args.user_message})
        _print(result.payload if result.ok else {"error": result.error})
    elif args.command == "history":
        result = ctx.engine.history({"session_id": args.session_id, "limit": args.limit})
        _print(result.payload)
    elif args.command == "close-session":
        result = ctx.engine.close_session({"session_id": args.session_id})
        _print(result.payload)
    elif args.command == "report":
        result = ctx.engine.report()
        _print(result.payload)
    elif args.command == "watchdog":
        result = ctx.engine.watchdog()
        _print(result.payload)
    elif args.command == "runserver":
        from .app import create_app

        app = create_app()
        app.run(host=args.host, port=args.port)
        ctx.engine.shutdown()
        return

    ctx.engine.shutdown()


if __name__ == "__main__":
    main()


===== config.py =====
"""Configuration primitives for the SPPR chat module."""

from __future__ import annotations

import os
from dataclasses import dataclass, field
from datetime import timedelta
from pathlib import Path
from typing import Any, Dict, List


def _env(key: str, default: str) -> str:
    value = os.getenv(key)
    return value if value is not None else default


def _env_int(key: str, default: int) -> int:
    try:
        return int(_env(key, str(default)))
    except ValueError:
        return default


def _env_float(key: str, default: float) -> float:
    try:
        return float(_env(key, str(default)))
    except ValueError:
        return default


def _env_bool(key: str, default: bool) -> bool:
    raw = _env(key, str(default)).lower()
    if raw in {"1", "true", "yes", "y"}:
        return True
    if raw in {"0", "false", "no", "n"}:
        return False
    return default


@dataclass(slots=True)
class RetrievalConfig:
    top_k: int = 5
    decay: float = 0.92
    freshness_hours: int = 48
    fallback_answers: List[str] = field(
        default_factory=lambda: [
            "Я уточню детали и вернусь с ответом.",
            "Пока собираю данные, попробуйте сформулировать вопрос иначе.",
        ]
    )


@dataclass(slots=True)
class IntentConfig:
    threshold: float = 0.55
    suggestions: int = 3
    cooldown_sec: int = 30


@dataclass(slots=True)
class SessionConfig:
    idle_timeout: timedelta = timedelta(minutes=20)
    max_turns: int = 50
    autosave_interval: timedelta = timedelta(minutes=5)


@dataclass(slots=True)
class TelemetryConfig:
    enable: bool = True
    interval: timedelta = timedelta(seconds=30)
    window: int = 1000


@dataclass(slots=True)
class AppConfig:
    base_dir: Path
    data_dir: Path
    database_url: str
    retrieval: RetrievalConfig = field(default_factory=RetrievalConfig)
    intents: IntentConfig = field(default_factory=IntentConfig)
    session: SessionConfig = field(default_factory=SessionConfig)
    telemetry: TelemetryConfig = field(default_factory=TelemetryConfig)
    extras: Dict[str, Any] = field(default_factory=dict)


def load_config(base_dir: Path | None = None) -> AppConfig:
    base = base_dir or Path(os.getenv("CHAT_SPPR_HOME", Path.cwd()))
    data_dir = base / "chat-data"
    data_dir.mkdir(parents=True, exist_ok=True)
    db_path = data_dir / "chat_sppr.db"

    retrieval = RetrievalConfig(
        top_k=_env_int("CHAT_RETRIEVAL_TOPK", 5),
        decay=_env_float("CHAT_RETRIEVAL_DECAY", 0.92),
        freshness_hours=_env_int("CHAT_RETRIEVAL_FRESHNESS_H", 48),
    )
    intents = IntentConfig(
        threshold=_env_float("CHAT_INTENT_THRESHOLD", 0.55),
        suggestions=_env_int("CHAT_INTENT_SUGGESTIONS", 3),
        cooldown_sec=_env_int("CHAT_INTENT_COOLDOWN", 30),
    )
    session = SessionConfig(
        idle_timeout=timedelta(minutes=_env_int("CHAT_SESSION_IDLE_MIN", 20)),
        max_turns=_env_int("CHAT_SESSION_MAX_TURNS", 50),
        autosave_interval=timedelta(minutes=_env_int("CHAT_SESSION_AUTOSAVE_MIN", 5)),
    )
    telemetry = TelemetryConfig(
        enable=_env_bool("CHAT_TELEMETRY", True),
        interval=timedelta(seconds=_env_int("CHAT_TELEMETRY_INTERVAL", 30)),
        window=_env_int("CHAT_TELEMETRY_WINDOW", 1000),
    )
    extras = {
        "instance_id": _env("CHAT_INSTANCE_ID", "chat-sppr-local"),
        "profile": _env("CHAT_PROFILE", "default"),
    }

    return AppConfig(
        base_dir=base,
        data_dir=data_dir,
        database_url=f"sqlite:///{db_path}",
        retrieval=retrieval,
        intents=intents,
        session=session,
        telemetry=telemetry,
        extras=extras,
    )


===== database.py =====
"""Database helpers for chat module."""

from __future__ import annotations

import contextlib
from typing import Iterator

from sqlalchemy import create_engine
from sqlalchemy.engine import Engine
from sqlalchemy.orm import DeclarativeBase, Session, sessionmaker


class Base(DeclarativeBase):
    """Declarative base."""


class Database:
    def __init__(self, url: str, echo: bool = False) -> None:
        self._engine: Engine = create_engine(url, echo=echo, future=True)
        self._session_factory = sessionmaker(bind=self._engine, expire_on_commit=False)

    def create_all(self) -> None:
        from . import models  # noqa: F401

        Base.metadata.create_all(self._engine)

    @contextlib.contextmanager
    def session(self) -> Iterator[Session]:
        session = self._session_factory()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()


===== engine.py =====
"""Engine orchestrating dialog logic."""

from __future__ import annotations

from contextlib import contextmanager
from dataclasses import dataclass
from datetime import timedelta
from typing import Any, Dict, List

from sqlalchemy import select

from . import models, utils
from .config import AppConfig
from .database import Database
from .repositories import AuditRepository, SessionRepository, TelemetryRepository
from .services.intent import IntentService
from .services.responder import ResponseService
from .services.retrieval import RetrievalService
from .services.scheduler import Scheduler
from .services.session import SessionService
from .services.watchdog import WatchdogService
from .telemetry import Telemetry


@dataclass
class EngineResult:
    ok: bool
    payload: Dict[str, Any]
    error: str | None = None


class ChatEngine:
    def __init__(self, config: AppConfig, database: Database):
        self.config = config
        self.database = database
        self.session_service = SessionService(config)
        self.intent_service = IntentService(config)
        self.retrieval_service = RetrievalService(config)
        self.response_service = ResponseService(config)
        self.watchdog_service = WatchdogService(config)
        self.telemetry = Telemetry(max_samples=config.telemetry.window)
        self.scheduler = Scheduler()
        self._setup_background_tasks()

    def _setup_background_tasks(self) -> None:
        if self.config.telemetry.enable:
            self.telemetry.configure_export(
                interval=self.config.telemetry.interval.total_seconds(),
                callback=self._persist_telemetry,
            )
            self.telemetry.ensure_running()
            self.scheduler.add_task(
                "telemetry",
                self.config.telemetry.interval.total_seconds(),
                lambda: None,
            )
        self.scheduler.start()

    @contextmanager
    def _session(self):
        with self.database.session() as session:
            yield session

    def ensure_user(self, payload: dict) -> EngineResult:
        with self._session() as session:
            result = self.session_service.ensure_user(
                session,
                payload["username"],
                payload.get("display_name", payload["username"]),
                payload.get("role", "operator"),
            )
            return EngineResult(True, result)

    def start_session(self, payload: dict) -> EngineResult:
        required = {"user_id", "title"}
        missing = required - payload.keys()
        if missing:
            return EngineResult(False, {}, f"missing fields: {', '.join(sorted(missing))}")
        with self._session() as session:
            result = self.session_service.start_session(session, payload["user_id"], payload["title"])
            self.telemetry.observe("sessions.started", 1.0)
            return EngineResult(True, result)

    def ask(self, payload: dict) -> EngineResult:
        required = {"session_id", "user_message"}
        missing = required - payload.keys()
        if missing:
            return EngineResult(False, {}, f"missing fields: {', '.join(sorted(missing))}")
        question = utils.normalize_text(payload["user_message"])
        with self._session() as session:
            history_turn = self.session_service.append_turn(
                session,
                session_id=payload["session_id"],
                role="user",
                content=question,
                tokens=len(utils.tokenize(question)),
                references=[],
                confidence=0.0,
            )
            intent = self.intent_service.detect(session, payload["session_id"], question)
            suggestions = self.intent_service.suggestions(question)
            references = self.retrieval_service.retrieve(session, question)
            response = self.response_service.compose(question, references)
            bot_turn = self.session_service.append_turn(
                session,
                session_id=payload["session_id"],
                role="assistant",
                content=response["text"],
                tokens=response["tokens"],
                references=response["references"],
                confidence=response["confidence"],
            )
            self.telemetry.observe("turns.total", 1.0)
            self.telemetry.observe("turns.tokens", response["tokens"])
            self.session_service.queue_suggestion(
                session,
                payload["session_id"],
                {"intent": intent["intent"], "hints": suggestions},
            )
            return EngineResult(
                True,
                {
                    "turn_id": bot_turn["turn_id"],
                    "response": response["text"],
                    "confidence": response["confidence"],
                    "references": references,
                    "intent": intent,
                    "suggestions": suggestions,
                },
            )

    def history(self, payload: dict) -> EngineResult:
        with self._session() as session:
            history = self.session_service.history(session, payload["session_id"], limit=payload.get("limit", 50))
            suggestions = self.session_service.fetch_suggestions(session, payload["session_id"])
            return EngineResult(True, {"history": history, "suggestions": suggestions})

    def close_session(self, payload: dict) -> EngineResult:
        with self._session() as session:
            self.session_service.close_session(session, payload["session_id"])
            self.telemetry.observe("sessions.closed", 1.0)
            return EngineResult(True, {"session_id": payload["session_id"], "status": "closed"})

    def feedback(self, payload: dict) -> EngineResult:
        with self._session() as session:
            result = self.session_service.feedback(
                session,
                turn_id=payload["turn_id"],
                score=payload["score"],
                comment=payload.get("comment"),
            )
            self.telemetry.observe("feedback.score", payload["score"])
            return EngineResult(True, result)

    def audit(self) -> EngineResult:
        with self._session() as session:
            repo = AuditRepository(session)
            entries = repo.latest()
            return EngineResult(
                True,
                {
                    "events": [
                        {"type": entry.event_type, "payload": entry.payload, "created_at": entry.created_at.isoformat()}
                        for entry in entries
                    ]
                },
            )

    def telemetry_snapshot(self) -> EngineResult:
        snapshot = self.telemetry.snapshot()
        return EngineResult(True, {"telemetry": snapshot})

    def report(self) -> EngineResult:
        with self._session() as session:
            repo = TelemetryRepository(session)
            snapshots = repo.recent("chat.metrics", limit=5)
            return EngineResult(
                True,
                {
                    "snapshots": [
                        {
                            "window_start": snap.window_start.isoformat(),
                            "window_end": snap.window_end.isoformat(),
                            "payload": snap.payload,
                        }
                        for snap in snapshots
                    ]
                },
            )

    def watchdog(self) -> EngineResult:
        with self._session() as session:
            summary = self.watchdog_service.inspect(session)
            payload = {
                "stale_sessions": summary.stale_sessions,
                "unanswered_turns": summary.unanswered_turns,
                "feedback": summary.low_feedback,
            }
            return EngineResult(True, payload)

    def shutdown(self) -> None:
        self.scheduler.stop()
        self.telemetry.stop()

    def _persist_telemetry(self, snapshot: Dict[str, Dict[str, float]]) -> None:
        with self._session() as session:
            repo = TelemetryRepository(session)
            now = utils.utc_now()
            repo.store(
                "chat.metrics",
                window_start=now - self.config.telemetry.interval,
                window_end=now,
                payload=snapshot,
            )


===== logging_setup.py =====
"""Logging helpers for chat module."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Dict


@dataclass(slots=True)
class LoggerConfig:
    level: int = logging.INFO
    fmt: str = "%(asctime)s | %(levelname)s | %(name)s | %(message)s"


def setup_logging(config: LoggerConfig | None = None) -> Dict[str, logging.Logger]:
    cfg = config or LoggerConfig()
    logging.basicConfig(level=cfg.level, format=cfg.fmt)
    return {
        "chat": logging.getLogger("chat"),
        "session": logging.getLogger("chat.session"),
        "intent": logging.getLogger("chat.intent"),
        "retrieval": logging.getLogger("chat.retrieval"),
        "api": logging.getLogger("chat.api"),
    }


===== models.py =====
"""ORM models for intelligent chat module."""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from sqlalchemy import (
    JSON,
    Boolean,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
    UniqueConstraint,
)
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .database import Base

Role = Enum("operator", "analyst", "guest", name="chat_role")


class User(Base):
    __tablename__ = "chat_users"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    username: Mapped[str] = mapped_column(String(64), unique=True, nullable=False)
    display_name: Mapped[str] = mapped_column(String(128), nullable=False)
    role: Mapped[str] = mapped_column(Role, default="operator")
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    sessions: Mapped[List["ChatSession"]] = relationship("ChatSession", back_populates="user")


class ChatSession(Base):
    __tablename__ = "chat_sessions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("chat_users.id"))
    title: Mapped[str] = mapped_column(String(256), nullable=False)
    status: Mapped[str] = mapped_column(String(32), default="active")
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    attributes: Mapped[Dict[str, Any]] = mapped_column(JSON, default=dict)

    user: Mapped["User"] = relationship("User", back_populates="sessions")
    turns: Mapped[List["Turn"]] = relationship(
        "Turn", back_populates="session", cascade="all, delete-orphan", order_by="Turn.position"
    )


class Turn(Base):
    __tablename__ = "chat_turns"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("chat_sessions.id"))
    position: Mapped[int] = mapped_column(Integer, nullable=False)
    role: Mapped[str] = mapped_column(String(16), nullable=False)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    tokens: Mapped[int] = mapped_column(Integer, default=0)
    references: Mapped[List[int]] = mapped_column(JSON, default=list)
    confidence: Mapped[float] = mapped_column(Float, default=0.0)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    session: Mapped["ChatSession"] = relationship("ChatSession", back_populates="turns")


class IntentSuggestion(Base):
    __tablename__ = "chat_intents"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("chat_sessions.id"))
    intent: Mapped[str] = mapped_column(String(128), nullable=False)
    confidence: Mapped[float] = mapped_column(Float, default=0.0)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    attributes: Mapped[Dict[str, Any]] = mapped_column(JSON, default=dict)

    session: Mapped["ChatSession"] = relationship("ChatSession")


class KnowledgeReference(Base):
    __tablename__ = "chat_references"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    turn_id: Mapped[int] = mapped_column(ForeignKey("chat_turns.id"))
    source_type: Mapped[str] = mapped_column(String(32), nullable=False)
    source_id: Mapped[str] = mapped_column(String(128), nullable=False)
    snippet: Mapped[str] = mapped_column(Text, nullable=False)
    score: Mapped[float] = mapped_column(Float, default=0.0)

    turn: Mapped["Turn"] = relationship("Turn")


class SuggestionQueue(Base):
    __tablename__ = "chat_suggestions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("chat_sessions.id"))
    payload: Mapped[Dict[str, Any]] = mapped_column(JSON, default=dict)
    expires_at: Mapped[datetime] = mapped_column(DateTime, nullable=False)
    processed: Mapped[bool] = mapped_column(Boolean, default=False)

    session: Mapped["ChatSession"] = relationship("ChatSession")


class Feedback(Base):
    __tablename__ = "chat_feedback"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    turn_id: Mapped[int] = mapped_column(ForeignKey("chat_turns.id"))
    score: Mapped[int] = mapped_column(Integer, nullable=False)
    comment: Mapped[str | None] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    turn: Mapped["Turn"] = relationship("Turn")


class AuditLog(Base):
    __tablename__ = "chat_audit"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    event_type: Mapped[str] = mapped_column(String(64), nullable=False)
    payload: Mapped[Dict[str, Any]] = mapped_column(JSON, default=dict)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)


class TelemetrySnapshot(Base):
    __tablename__ = "chat_telemetry"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    metric_name: Mapped[str] = mapped_column(String(64), nullable=False)
    window_start: Mapped[datetime] = mapped_column(DateTime, nullable=False)
    window_end: Mapped[datetime] = mapped_column(DateTime, nullable=False)
    payload: Mapped[Dict[str, Any]] = mapped_column(JSON, default=dict)


===== repositories.py =====
"""Repository helpers for chat module."""

from __future__ import annotations

from datetime import datetime, timedelta
from typing import Dict, List, Sequence

from sqlalchemy import func, select
from sqlalchemy.orm import Session

from . import models


class BaseRepository:
    def __init__(self, session: Session):
        self.session = session


class UserRepository(BaseRepository):
    def get_or_create(self, username: str, display_name: str, role: str) -> models.User:
        stmt = select(models.User).where(models.User.username == username)
        user = self.session.scalar(stmt)
        if user:
            return user
        user = models.User(username=username, display_name=display_name, role=role)
        self.session.add(user)
        self.session.flush()
        return user


class SessionRepository(BaseRepository):
    def create(self, user_id: int, title: str) -> models.ChatSession:
        session = models.ChatSession(user_id=user_id, title=title)
        self.session.add(session)
        self.session.flush()
        return session

    def resolve(self, session_id: int) -> models.ChatSession | None:
        return self.session.get(models.ChatSession, session_id)

    def close(self, session_id: int) -> None:
        chat_session = self.resolve(session_id)
        if chat_session:
            chat_session.status = "closed"
            chat_session.updated_at = datetime.utcnow()

    def list_active(self, user_id: int, limit: int = 10) -> List[models.ChatSession]:
        stmt = (
            select(models.ChatSession)
            .where(models.ChatSession.user_id == user_id, models.ChatSession.status == "active")
            .order_by(models.ChatSession.updated_at.desc())
            .limit(limit)
        )
        return list(self.session.scalars(stmt))


class TurnRepository(BaseRepository):
    def add_turn(
        self,
        session_id: int,
        role: str,
        content: str,
        tokens: int,
        references: List[int],
        confidence: float,
    ) -> models.Turn:
        position = self._next_position(session_id)
        turn = models.Turn(
            session_id=session_id,
            position=position,
            role=role,
            content=content,
            tokens=tokens,
            references=references,
            confidence=confidence,
        )
        self.session.add(turn)
        self.session.flush()
        chat_session = self.session.get(models.ChatSession, session_id)
        if chat_session:
            chat_session.updated_at = datetime.utcnow()
        return turn

    def history(self, session_id: int, limit: int = 50) -> List[models.Turn]:
        stmt = (
            select(models.Turn)
            .where(models.Turn.session_id == session_id)
            .order_by(models.Turn.position.asc())
            .limit(limit)
        )
        return list(self.session.scalars(stmt))

    def _next_position(self, session_id: int) -> int:
        stmt = select(func.max(models.Turn.position)).where(models.Turn.session_id == session_id)
        current = self.session.scalar(stmt) or 0
        return current + 1


class IntentRepository(BaseRepository):
    def record(self, session_id: int, intent: str, confidence: float, attributes: Dict) -> models.IntentSuggestion:
        suggestion = models.IntentSuggestion(
            session_id=session_id,
            intent=intent,
            confidence=confidence,
            attributes=attributes,
        )
        self.session.add(suggestion)
        self.session.flush()
        return suggestion

    def latest(self, session_id: int, limit: int = 5) -> List[models.IntentSuggestion]:
        stmt = (
            select(models.IntentSuggestion)
            .where(models.IntentSuggestion.session_id == session_id)
            .order_by(models.IntentSuggestion.created_at.desc())
            .limit(limit)
        )
        return list(self.session.scalars(stmt))


class ReferenceRepository(BaseRepository):
    def attach(self, turn_id: int, references: Sequence[Dict[str, str]]) -> None:
        for payload in references:
            reference = models.KnowledgeReference(
                turn_id=turn_id,
                source_type=payload["source_type"],
                source_id=payload["source_id"],
                snippet=payload["snippet"],
                score=payload.get("score", 0.0),
            )
            self.session.add(reference)

    def list_for_turn(self, turn_id: int) -> List[models.KnowledgeReference]:
        stmt = select(models.KnowledgeReference).where(models.KnowledgeReference.turn_id == turn_id)
        return list(self.session.scalars(stmt))


class SuggestionRepository(BaseRepository):
    def enqueue(self, session_id: int, payload: Dict, expires_at: datetime) -> models.SuggestionQueue:
        entry = models.SuggestionQueue(session_id=session_id, payload=payload, expires_at=expires_at)
        self.session.add(entry)
        self.session.flush()
        return entry

    def pull(self, session_id: int) -> List[models.SuggestionQueue]:
        stmt = (
            select(models.SuggestionQueue)
            .where(
                models.SuggestionQueue.session_id == session_id,
                models.SuggestionQueue.processed.is_(False),
                models.SuggestionQueue.expires_at > datetime.utcnow(),
            )
            .order_by(models.SuggestionQueue.id.asc())
        )
        entries = list(self.session.scalars(stmt))
        for entry in entries:
            entry.processed = True
        return entries


class FeedbackRepository(BaseRepository):
    def add(self, turn_id: int, score: int, comment: str | None) -> models.Feedback:
        feedback = models.Feedback(turn_id=turn_id, score=score, comment=comment)
        self.session.add(feedback)
        self.session.flush()
        return feedback

    def stats(self, since: datetime) -> Dict[str, float]:
        stmt = select(func.avg(models.Feedback.score)).where(models.Feedback.created_at >= since)
        avg_score = self.session.scalar(stmt) or 0.0
        count = self.session.scalar(
            select(func.count(models.Feedback.id)).where(models.Feedback.created_at >= since)
        ) or 0
        return {"avg_score": float(avg_score), "count": int(count)}


class AuditRepository(BaseRepository):
    def add(self, event_type: str, payload: Dict) -> None:
        entry = models.AuditLog(event_type=event_type, payload=payload)
        self.session.add(entry)

    def latest(self, limit: int = 50) -> List[models.AuditLog]:
        stmt = select(models.AuditLog).order_by(models.AuditLog.created_at.desc()).limit(limit)
        return list(self.session.scalars(stmt))


class TelemetryRepository(BaseRepository):
    def store(self, name: str, window_start: datetime, window_end: datetime, payload: Dict) -> None:
        snapshot = models.TelemetrySnapshot(
            metric_name=name,
            window_start=window_start,
            window_end=window_end,
            payload=payload,
        )
        self.session.add(snapshot)

    def recent(self, name: str, limit: int = 5) -> List[models.TelemetrySnapshot]:
        stmt = (
            select(models.TelemetrySnapshot)
            .where(models.TelemetrySnapshot.metric_name == name)
            .order_by(models.TelemetrySnapshot.window_end.desc())
            .limit(limit)
        )
        return list(self.session.scalars(stmt))


===== telemetry.py =====
"""Telemetry collector for chat module."""

from __future__ import annotations

import threading
import time
from dataclasses import dataclass, field
from typing import Callable, Dict, List


@dataclass
class MetricSample:
    timestamp: float
    value: float


@dataclass
class Metric:
    name: str
    max_samples: int
    samples: List[MetricSample] = field(default_factory=list)

    def add(self, value: float) -> None:
        self.samples.append(MetricSample(time.time(), value))
        if len(self.samples) > self.max_samples:
            self.samples = self.samples[-self.max_samples :]

    def average(self) -> float:
        if not self.samples:
            return 0.0
        return sum(sample.value for sample in self.samples) / len(self.samples)

    def latest(self) -> float:
        return self.samples[-1].value if self.samples else 0.0


class Telemetry:
    def __init__(self, max_samples: int = 1000):
        self.metrics: Dict[str, Metric] = {}
        self.max_samples = max_samples
        self._lock = threading.Lock()
        self._thread: threading.Thread | None = None
        self._stop = threading.Event()
        self._callback: Callable[[Dict[str, Dict[str, float]]], None] | None = None
        self.interval = 30.0

    def observe(self, name: str, value: float) -> None:
        with self._lock:
            metric = self.metrics.setdefault(name, Metric(name, self.max_samples))
            metric.add(value)

    def snapshot(self) -> Dict[str, Dict[str, float]]:
        with self._lock:
            return {
                name: {
                    "average": metric.average(),
                    "latest": metric.latest(),
                    "samples": len(metric.samples),
                }
                for name, metric in self.metrics.items()
            }

    def configure_export(self, interval: float, callback: Callable[[Dict[str, Dict[str, float]]], None]) -> None:
        self.interval = interval
        self._callback = callback

    def start(self) -> None:
        if self._thread or not self._callback:
            return

    def _loop(self):
        while not self._stop.wait(self.interval):
            self._callback(self.snapshot())
        self._callback(self.snapshot())

    def ensure_running(self) -> None:
        if self._thread or not self._callback:
            return
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self) -> None:
        if self._thread:
            self._stop.set()
            self._thread.join(timeout=2)
            self._thread = None
            self._stop.clear()


===== utils.py =====
"""Utility helpers for chat processing."""

from __future__ import annotations

import hashlib
import random
import re
import statistics
from datetime import datetime, timezone
from typing import Iterable, List

STOPWORDS = {"и", "в", "на", "с", "по", "для", "из", "не", "что", "как", "к"}


def utc_now() -> datetime:
    return datetime.now(tz=timezone.utc).replace(tzinfo=None)


def normalize_text(text: str) -> str:
    text = re.sub(r"\s+", " ", text).strip()
    return text


def tokenize(text: str) -> List[str]:
    tokens = re.findall(r"[a-zA-Zа-яА-Я0-9]{3,}", text.lower())
    return [token for token in tokens if token not in STOPWORDS]


def fuzzy_similarity(a: str, b: str) -> float:
    if not a or not b:
        return 0.0
    overlap = len(set(tokenize(a)) & set(tokenize(b)))
    union = len(set(tokenize(a)) | set(tokenize(b))) or 1
    return overlap / union


def heuristic_answer(question: str, references: Iterable[str]) -> str:
    base = normalize_text(question)
    ref = next(iter(references), "")
    return f"Вопрос: {base}. Согласно источнику: {ref[:200]}..."


def message_hash(content: str) -> str:
    return hashlib.sha256(content.encode("utf-8")).hexdigest()


def rolling_average(values: Iterable[float], window: int = 5) -> float:
    data = list(values)[-window:]
    return statistics.fmean(data) if data else 0.0


def random_ack() -> str:
    phrases = [
        "Понял запрос, проверяю материалы.",
        "Уточняю детали в базе знаний.",
        "Обновляю контекст беседы.",
    ]
    return random.choice(phrases)


===== api/routes.py =====
"""Flask blueprint exposing chat API."""

from __future__ import annotations

from flask import Blueprint, jsonify, request

from ..engine import ChatEngine
from . import schemas


def create_blueprint(engine: ChatEngine) -> Blueprint:
    bp = Blueprint("chat_api", __name__)

    @bp.route("/health", methods=["GET"])
    def health():
        return jsonify(schemas.success({"status": "ok"}).to_dict())

    @bp.route("/users", methods=["POST"])
    def ensure_user():
        payload = request.get_json(force=True, silent=True) or {}
        result = engine.ensure_user(payload)
        envelope = schemas.success(result.payload) if result.ok else schemas.failure(result.error or "error")
        return jsonify(envelope.to_dict()), (200 if result.ok else 400)

    @bp.route("/sessions", methods=["POST"])
    def start_session():
        payload = request.get_json(force=True, silent=True) or {}
        result = engine.start_session(payload)
        envelope = schemas.success(result.payload) if result.ok else schemas.failure(result.error or "error")
        return jsonify(envelope.to_dict()), (200 if result.ok else 400)

    @bp.route("/sessions/<int:session_id>/ask", methods=["POST"])
    def ask(session_id: int):
        payload = request.get_json(force=True, silent=True) or {}
        payload["session_id"] = session_id
        result = engine.ask(payload)
        envelope = schemas.success(result.payload) if result.ok else schemas.failure(result.error or "error")
        return jsonify(envelope.to_dict()), (200 if result.ok else 400)

    @bp.route("/sessions/<int:session_id>/history", methods=["GET"])
    def history(session_id: int):
        result = engine.history({"session_id": session_id, "limit": int(request.args.get("limit", 50))})
        return jsonify(schemas.success(result.payload).to_dict())

    @bp.route("/sessions/<int:session_id>/close", methods=["POST"])
    def close_session(session_id: int):
        result = engine.close_session({"session_id": session_id})
        return jsonify(schemas.success(result.payload).to_dict())

    @bp.route("/feedback", methods=["POST"])
    def feedback():
        payload = request.get_json(force=True, silent=True) or {}
        result = engine.feedback(payload)
        envelope = schemas.success(result.payload) if result.ok else schemas.failure(result.error or "error")
        return jsonify(envelope.to_dict()), (200 if result.ok else 400)

    @bp.route("/audit", methods=["GET"])
    def audit():
        result = engine.audit()
        return jsonify(schemas.success(result.payload).to_dict())

    @bp.route("/telemetry", methods=["GET"])
    def telemetry():
        result = engine.telemetry_snapshot()
        return jsonify(schemas.success(result.payload).to_dict())

    @bp.route("/report", methods=["GET"])
    def report():
        result = engine.report()
        return jsonify(schemas.success(result.payload).to_dict())

    @bp.route("/watchdog", methods=["GET"])
    def watchdog():
        result = engine.watchdog()
        return jsonify(schemas.success(result.payload).to_dict())

    return bp


===== api/schemas.py =====
"""Response schema utilities for chat API."""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict


def iso(dt: datetime | None = None) -> str:
    dt = dt or datetime.utcnow()
    return dt.replace(microsecond=0).isoformat() + "Z"


@dataclass
class Envelope:
    ok: bool
    payload: Dict[str, Any]
    error: str | None = None

    def to_dict(self) -> Dict[str, Any]:
        return {"ok": self.ok, "payload": self.payload, "error": self.error, "timestamp": iso()}


def success(payload: Dict[str, Any]) -> Envelope:
    return Envelope(True, payload)


def failure(message: str) -> Envelope:
    return Envelope(False, {}, message)


===== services/intent.py =====
"""Intent detection and suggestion service."""

from __future__ import annotations

import logging
import random
from typing import Dict, List

from sqlalchemy.orm import Session

from ..config import AppConfig
from ..repositories import IntentRepository, TurnRepository
from .. import utils

LOGGER = logging.getLogger("chat.intent")


class IntentService:
    def __init__(self, config: AppConfig):
        self.config = config

    def detect(self, session: Session, session_id: int, question: str) -> dict:
        repo = IntentRepository(session)
        history_repo = TurnRepository(session)
        turns = history_repo.history(session_id, limit=10)
        score = utils.fuzzy_similarity(question, " ".join(turn.content for turn in turns if turn.role == "user"))
        intent = self._classify(question)
        metadata = {"similarity": score}
        repo.record(session_id, intent, score, metadata)
        LOGGER.debug("Intent %s detected with score %.2f", intent, score)
        return {"intent": intent, "confidence": score}

    def suggestions(self, question: str) -> List[str]:
        base = [
            "Попросить аналитическое резюме",
            "Запросить источники, подтверждающие выводы",
            "Построить временную линию событий",
        ]
        tokens = utils.tokenize(question)
        if "отчет" in tokens:
            base.append("Сформировать отчёт по текущей теме")
        return base[: self.config.intents.suggestions]

    def _classify(self, text: str) -> str:
        tokens = utils.tokenize(text)
        if "источник" in tokens or "документ" in tokens:
            return "request_sources"
        if "сценарий" in tokens:
            return "scenario_analysis"
        if "обоснуй" in text.lower():
            return "justify_answer"
        return random.choice(["general_query", "status_check", "explain_terms"])


===== services/responder.py =====
"""Response generation helper."""

from __future__ import annotations

import logging
from typing import Dict, List

from ..config import AppConfig
from .. import utils

LOGGER = logging.getLogger("chat.responder")


class ResponseService:
    def __init__(self, config: AppConfig):
        self.config = config

    def compose(self, question: str, references: List[Dict]) -> Dict:
        text = utils.heuristic_answer(question, [ref["snippet"] for ref in references])
        tokens = len(utils.tokenize(text))
        confidence = min(1.0, sum(ref["score"] for ref in references) / max(len(references), 1))
        LOGGER.debug("Response composed with confidence %.2f", confidence)
        return {
            "text": text,
            "tokens": tokens,
            "confidence": confidence,
            "references": [ref.get("turn_id", 0) for ref in references],
        }


===== services/retrieval.py =====
"""Retrieval stub service linking chat to knowledge references."""

from __future__ import annotations

import logging
import random
from datetime import datetime, timedelta
from typing import Dict, List

from sqlalchemy import select
from sqlalchemy.orm import Session

from ..config import AppConfig
from .. import models, utils

LOGGER = logging.getLogger("chat.retrieval")


class RetrievalService:
    def __init__(self, config: AppConfig):
        self.config = config

    def retrieve(self, session: Session, question: str) -> List[Dict]:
        since = datetime.utcnow() - timedelta(hours=self.config.retrieval.freshness_hours)
        stmt = (
            select(models.ChatSession)
            .where(models.ChatSession.updated_at >= since)
            .order_by(models.ChatSession.updated_at.desc())
            .limit(50)
        )
        sessions = list(session.scalars(stmt))
        references = []
        for chat_session in sessions:
            for turn in chat_session.turns[-3:]:
                similarity = utils.fuzzy_similarity(question, turn.content)
                if similarity >= self.config.retrieval.decay:
                    references.append(
                        {
                            "session_id": chat_session.id,
                            "turn_id": turn.id,
                            "snippet": turn.content[:200],
                            "score": similarity,
                        }
                    )
        if not references:
            references.append(
                {
                    "session_id": 0,
                    "turn_id": 0,
                    "snippet": random.choice(self.config.retrieval.fallback_answers),
                    "score": 0.1,
                }
            )
        references.sort(key=lambda item: item["score"], reverse=True)
        return references[: self.config.retrieval.top_k]


===== services/scheduler.py =====
"""Periodic task scheduler for chat module."""

from __future__ import annotations

import threading
import time
from dataclasses import dataclass
from typing import Callable, Dict


@dataclass
class ScheduledTask:
    name: str
    interval: float
    handler: Callable[[], None]
    last_run: float = 0.0


class Scheduler:
    def __init__(self):
        self._tasks: Dict[str, ScheduledTask] = {}
        self._thread: threading.Thread | None = None
        self._stop = threading.Event()

    def add_task(self, name: str, interval: float, handler: Callable[[], None]) -> None:
        self._tasks[name] = ScheduledTask(name=name, interval=interval, handler=handler)

    def start(self) -> None:
        if self._thread:
            return

        def _loop():
            while not self._stop.is_set():
                now = time.time()
                for task in self._tasks.values():
                    if now - task.last_run >= task.interval:
                        try:
                            task.handler()
                        finally:
                            task.last_run = now
                self._stop.wait(1.0)

        self._thread = threading.Thread(target=_loop, daemon=True)
        self._thread.start()

    def stop(self) -> None:
        if self._thread:
            self._stop.set()
            self._thread.join(timeout=2)
            self._thread = None
            self._stop.clear()


===== services/session.py =====
"""Session management service."""

from __future__ import annotations

import logging
from datetime import datetime, timedelta

from sqlalchemy.orm import Session

from ..config import AppConfig
from ..repositories import (
    AuditRepository,
    FeedbackRepository,
    SessionRepository,
    SuggestionRepository,
    TurnRepository,
    UserRepository,
)
from .. import utils

LOGGER = logging.getLogger("chat.session")


class SessionService:
    def __init__(self, config: AppConfig):
        self.config = config

    def ensure_user(self, session: Session, username: str, display_name: str, role: str) -> dict:
        repo = UserRepository(session)
        user = repo.get_or_create(username, display_name, role)
        return {"user_id": user.id, "username": user.username, "role": user.role}

    def start_session(self, session: Session, user_id: int, title: str) -> dict:
        repo = SessionRepository(session)
        chat_session = repo.create(user_id, title=title)
        LOGGER.info("Session %s started for user %s", chat_session.id, user_id)
        return {"session_id": chat_session.id, "title": chat_session.title}

    def append_turn(
        self,
        session: Session,
        session_id: int,
        role: str,
        content: str,
        tokens: int,
        references: list[int] | None = None,
        confidence: float = 0.0,
    ) -> dict:
        reference_ids = references or []
        turn_repo = TurnRepository(session)
        turn = turn_repo.add_turn(
            session_id=session_id,
            role=role,
            content=content,
            tokens=tokens,
            references=reference_ids,
            confidence=confidence,
        )
        return {
            "turn_id": turn.id,
            "position": turn.position,
            "content": turn.content,
            "role": turn.role,
            "references": turn.references,
        }

    def history(self, session_db: Session, session_id: int, limit: int = 50) -> list[dict]:
        repo = TurnRepository(session_db)
        turns = repo.history(session_id, limit=limit)
        return [
            {
                "position": turn.position,
                "role": turn.role,
                "content": turn.content,
                "confidence": turn.confidence,
                "created_at": turn.created_at.isoformat(),
            }
            for turn in turns
        ]

    def queue_suggestion(self, session: Session, session_id: int, payload: dict) -> None:
        repo = SuggestionRepository(session)
        expires_at = utils.utc_now() + timedelta(seconds=self.config.intents.cooldown_sec)
        repo.enqueue(session_id, payload, expires_at)

    def fetch_suggestions(self, session: Session, session_id: int) -> list[dict]:
        repo = SuggestionRepository(session)
        items = repo.pull(session_id)
        return [{"payload": item.payload, "expires_at": item.expires_at.isoformat()} for item in items]

    def close_session(self, session: Session, session_id: int) -> None:
        repo = SessionRepository(session)
        repo.close(session_id)
        LOGGER.info("Session %s closed", session_id)

    def feedback(self, session: Session, turn_id: int, score: int, comment: str | None) -> dict:
        repo = FeedbackRepository(session)
        record = repo.add(turn_id, score, comment)
        return {"feedback_id": record.id, "score": record.score}


===== services/watchdog.py =====
"""Watchdog service for chat module."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List

from sqlalchemy import func, select
from sqlalchemy.orm import Session

from .. import models, utils


@dataclass
class WatchdogSummary:
    stale_sessions: List[int]
    unanswered_turns: int
    low_feedback: Dict[str, float]


class WatchdogService:
    def __init__(self, config):
        self.config = config

    def inspect(self, session: Session) -> WatchdogSummary:
        cutoff = utils.utc_now() - self.config.session.idle_timeout
        stale = session.scalars(
            select(models.ChatSession.id)
            .where(models.ChatSession.status == "active")
            .where(models.ChatSession.updated_at < cutoff)
        ).all()
        unanswered = session.scalar(
            select(func.count(models.Turn.id)).where(
                models.Turn.role == "user",
                ~models.Turn.id.in_(select(models.KnowledgeReference.turn_id)),
            )
        ) or 0
        avg = session.scalar(select(func.avg(models.Feedback.score))) or 0.0
        return WatchdogSummary(
            stale_sessions=stale,
            unanswered_turns=int(unanswered),
            low_feedback={"avg_score": float(avg)},
        )

